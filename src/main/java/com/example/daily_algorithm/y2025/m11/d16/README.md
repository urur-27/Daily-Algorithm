# 🧩 26. Remove Duplicates from Sorted Array

**난이도:** Easy  
**플랫폼:** LeetCode  
**유형:** Two Pointers / Array  
**링크:** https://leetcode.com/problems/remove-duplicates-from-sorted-array/
---

## 📝 문제 설명

정수 배열 `nums`가 **오름차순(Non-decreasing)** 으로 정렬되어 주어진다.  
이 배열에서 **중복된 원소를 제거하여**,  
각 **고유한 원소가 한 번만 등장하도록** in-place로 정리해야 한다.

정리 후, 배열 앞쪽에는 **중복 없이 정렬된 고유 원소들만** 차례대로 위치해야 하며,  
그 개수를 `k`라고 한다.

함수는 이 `k` 값을 반환해야 하며,  
배열의 `k` 이후 부분에 어떤 값이 남아있든 상관없다.

---

## 🔍 예시

**예시 1**

입력:  
`nums = [1,1,2]`  
출력:  
`2, nums = [1,2,_]`

설명:  
고유 원소는 `[1, 2]`이므로 `k = 2`  
앞의 두 칸은 `[1, 2]`가 되어야 하며,  
그 이후의 값은 무엇이든 무방하다.

---

**예시 2**

입력:  
`nums = [0,0,1,1,1,2,2,3,3,4]`  
출력:  
`5, nums = [0,1,2,3,4,_,_,_,_,_]`

설명:  
고유 원소는 `[0,1,2,3,4]` → `k = 5`  
배열의 앞 5개 요소는 반드시 이 값들과 같아야 한다.

---

## 📋 제약 조건 (Constraints)

- 1 <= nums.length <= 3 * 10⁴
- -100 <= nums[i] <= 100
- `nums`는 **오름차순 정렬**된 상태로 주어진다.
---

## 💡 접근 방식

배열 nums는 길이가 최소 1 이상이므로
첫 번째 원소는 무조건 고유다.
→ 따라서 k = 1로 시작한다. (k = 고유 원소 개수)

인덱스 i를 1부터 끝까지 순회하면서 다음을 체크한다:

nums[i]가 nums[k-1]과 다르다면
→ 새로운 고유 원소 등장
→ nums[k] 위치에 그 값을 저장하고
→ k++ 증가시킨다.

이렇게 하면 배열의 앞 k칸에는 중복 없는 값들이 저장되고,
그 이후는 어떤 값이 남아있어도 문제에서 상관하지 않는다.