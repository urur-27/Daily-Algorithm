# 🧩 219. Contains Duplicate II

**난이도:** Easy  
**플랫폼:** LeetCode  
**유형:** HashMap, Sliding Window  
**링크:** https://leetcode.com/problems/contains-duplicate-ii/
---

## 📝 문제 설명

정수 배열 `nums`와 정수 `k`가 주어진다.  
배열 내에서 **같은 값이 k 거리 이내에 다시 등장하는지** 확인하는 문제이다.

즉,  
어떤 값 `nums[i]` 와 `nums[j]` 가 존재하며 다음 조건을 만족한다면 `true` 를 반환한다:

1. `nums[i] == nums[j]`
2. `|i - j| <= k`

그런 값이 없다면 `false` 를 반환한다.

---

## 🔍 예시

### ✔ 예시 1
입력

    nums = [1,2,3,1], k = 3

출력

    true

설명:  
값 1이 인덱스 0과 3에서 등장하며 거리 3이므로 조건 만족.

---

### ✔ 예시 2
입력

    nums = [1,0,1,1], k = 1

출력

    true

설명:  
값 1이 인덱스 2와 3에서 등장하며 거리 1.

---

### ✔ 예시 3
입력

    nums = [1,2,3,1,2,3], k = 2

출력

    false

설명:  
같은 값이 등장하긴 하지만 거리가 모두 k=2보다 큼.

---

## 📋 제약 조건 (Constraints)

- `1 ≤ nums.length ≤ 10⁵`
- `-10⁹ ≤ nums[i] ≤ 10⁹`
- `0 ≤ k ≤ 10⁵`

---

## 💡 접근 방식

이 문제는 배열에서 **같은 값이 k 거리 이내에 다시 등장하는지** 확인하는 문제이다.  
이를 효율적으로 처리하기 위해 HashMap을 사용한다.

---

### ✔ 1) HashMap에 값을 저장하는 이유

HashMap은 **Key 기반으로 값을 매우 빠르게(O(1)) 조회할 수 있는 자료구조**이다.  
이 문제에서는 다음 구조로 저장한다:

- **key → 배열 값(nums[i])**
- **value → 해당 값이 등장한 최신 인덱스(i)**

예를 들어,  
nums = [1, 0, 1] 이라고 하면 HashMap은 다음과 같이 변화한다:

```
i=0 → map.put(1, 0)   → {1=0}
i=1 → map.put(0, 1)   → {1=0, 0=1}
i=2 → map.put(1, 2)   → {1=2, 0=1}
```

---

### ✔ 2) “중복 key가 덮어써지는 특성”이 왜 유리할까?

HashMap은 **같은 key를 여러 개 저장할 수 없다.**  
즉,

    map.put(1, 0);
    map.put(1, 2);

이렇게 하면 두 번째 put이 첫 번째 값을 덮어쓴다.  
결과:

    1 → 2

이 문제에서는 이 특성이 오히려 매우 유용하다.

왜냐하면 문제의 목적은:

> **같은 값이 k 거리 이내에 또 등장하는지 확인하는 것**  
> → 즉, “가장 가까운 동일 값”만 확인하면 충분하다.

이전 오래된 인덱스는 거리가 더 멀기 때문에 고려할 필요가 없다.

따라서:

- HashMap이 자동으로 “가장 최근 등장 인덱스”로 덮어쓰기
- 다음에 같은 값이 나오면 “가장 가까운 인덱스”와만 비교
- 문제 조건과 정확히 일치하는 동작

---

### ✔ 3) 동작 흐름 요약

1. 배열을 왼쪽부터 순회한다.
2. 현재 값(nums[i])이 map에 이미 있다면

       prevIndex = map.get(nums[i])

   이전 등장 위치를 즉시 얻을 수 있다.

3. 거리 계산:

       if (i - prevIndex <= k) → true

4. 항상 최신 인덱스로 갱신:

       map.put(nums[i], i)

---

### ✔ 4) 전체 아이디어 한 줄 요약

> HashMap은 동일한 key를 중복 저장할 수 없어  
> **항상 최신 인덱스로 덮어쓴다.**  
> 이 문제에서는 “가장 가까운 거리만 확인하면 되기 때문에”  
> 이 특성이 오히려 정답 풀이에 아주 적합하다.

---

### ✔ 5) 시간복잡도

- HashMap 조회/삽입: 평균 **O(1)**
- 전체 배열 순회: **O(n)**  
  → 전체 시간복잡도: **O(n)**



---

## 코드
