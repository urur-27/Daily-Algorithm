# 🧩 876. Middle of the Linked List

**난이도:** Easy  
**플랫폼:** LeetCode  
**유형:** Two Pointers / Linked List  
**링크:** https://leetcode.com/problems/middle-of-the-linked-list/
---

## 📝 문제 설명

단일 연결 리스트(singly linked list)의 head가 주어졌을 때,  
이 리스트의 **중간 노드(middle node)** 를 반환하라.

리스트의 길이가 짝수라서 가운데 노드가 두 개라면,  
**두 번째 중간 노드(second middle node)** 를 반환해야 한다.

---

## 🔍 예시

**예시 1**

입력:  
`head = [1,2,3,4,5]`  
출력:  
`[3,4,5]`  
설명:  
리스트의 중간 노드는 값이 3인 노드이다.

---

**예시 2**

입력:  
`head = [1,2,3,4,5,6]`  
출력:  
`[4,5,6]`  
설명:  
리스트 길이가 짝수이므로 중간 노드가 3과 4 두 개가 존재한다.  
문제 요구에 따라 **두 번째 중간 노드인 4**를 반환해야 한다.

---

## 📋 제약 조건 (Constraints)

- 리스트의 노드 수는 최소 1 이상
- `1 <= Node.val <= 100`
---





## 💡 내가 떠올린 접근 방식

이 문제는 단일 연결 리스트에서 **중간 노드를 찾아 반환하는 문제**이다.  
처음에는 다음과 같은 방식으로 접근했다.

1. **리스트 전체 길이를 센다.**  
   재귀 함수를 사용하여 head부터 끝까지 탐색하며 노드 개수를 세려고 했다.

2. **중간 인덱스를 계산한다.**  
   길이가 `n`이면 `n / 2`가 중간 인덱스이므로,  
   그 위치가 곧 문제에서 요구하는 "중간 노드"가 된다.
    - 예: n = 5 → 5/2 = 2 → 세 번째 노드
    - 예: n = 6 → 6/2 = 3 → 네 번째 노드 (두 번째 중간) → 문제 요구 조건 충족

3. **해당 위치의 노드를 찾아 반환하려고 했다.**  
   다시 head부터 시작해 중간 인덱스까지 이동한 뒤,  
   그 노드를 반환하는 방식을 생각했다.

이 방식은 **논리적으로는 맞는 풀이이며 충분히 정답이 나오는 접근**이다.  
다만 구현 과정에서
- 재귀 로직의 종료 조건
- 파라미터 전달
- 새로운 노드를 생성해 반환하려 한 부분 등이 혼동을 일으켰다.  
  연결 리스트는 **기존 노드를 그대로 반환**해야 하며,  
  새로운 `ListNode`를 만들 필요가 없다.

---

## ⚙️ 같은 아이디어를 반복문으로 구현한 안전한 방법

위의 아이디어를 더 단순하게 정돈하면 다음과 같이 풀 수 있다.

1. head부터 시작해서 끝까지 순회하며 전체 길이 `len`을 구한다.
2. `middle = len / 2` 로 중간 인덱스를 계산한다.
3. 다시 head에서 시작해 `middle`번 이동한 뒤 그 노드를 반환한다.

이 방식은 리스트를 **두 번 순회(O(n))**하며,  
문제의 요구사항을 정확히 만족한다.

---

## 🚀 더 좋은 풀이: 빠른/느린 포인터(Fast & Slow Pointer)

이 문제의 가장 전형적이고 효율적인 해법은  
**빠른 포인터(fast)** 와 **느린 포인터(slow)** 를 사용하는 것이다.

- `slow` 는 **한 칸씩** 이동
- `fast` 는 **두 칸씩** 이동
- `fast` 가 리스트 끝에 도달하는 순간  
  → `slow` 는 정확히 **중간 노드**에 도달하게 된다.

짝수 길이인 경우에도  
`fast` 가 끝을 통과하면  
`slow` 는 두 번째 중간 노드에 위치하게 되어  
문제 조건을 자연스럽게 만족한다.

### 장점
- 리스트 **한 번만 순회 → O(n)**
- 길이를 미리 세지 않아도 됨
- 코드가 매우 간결하고 실수가 적음

---

## 💻 코드 (Fast & Slow Pointer)

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;        // 느린 포인터: 한 칸 이동
            fast = fast.next.next;   // 빠른 포인터: 두 칸 이동
        }    
        return slow; // 중간 노드 반환
}
```

