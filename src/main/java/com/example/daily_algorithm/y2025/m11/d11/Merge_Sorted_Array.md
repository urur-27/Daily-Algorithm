# 🧩 

**난이도:** Easy  
**플랫폼:** LeetCode  
**유형:** 
**링크:** 
---

## 📝 문제 설명



---

## 🔍 예시


---

## 📋 제약 조건 (Constraints)



---

## 💡 접근 방식



---

## 코드

```java

# 🧩 88. Merge Sorted Array

**난이도:** Easy  
**플랫폼:** LeetCode  
**유형:** 배열(Array), 두 포인터(Two Pointers), 정렬(Sorting)  
**링크:** [LeetCode #88 - Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array)  
---

## 📝 문제 설명

두 개의 정수 배열 `nums1`과 `nums2`가 **비내림차순(오름차순)** 으로 정렬되어 있다.  
또한 각각의 원소 개수를 나타내는 정수 `m`, `n`이 주어진다.

`nums1`과 `nums2`를 하나의 **비내림차순으로 정렬된 단일 배열**로 합쳐야 한다.

최종 정렬된 배열은 새로 반환하지 않고, `nums1` 내부에 저장해야 한다.  
이를 위해 `nums1`의 길이는 `m + n`이며,  
앞의 `m`개의 원소는 실제 데이터,  
뒤의 `n`개의 원소는 0으로 채워져 있으며 무시해야 한다.

---

## 🔍 예시

**예제 1**

입력:  
nums1 = [1,2,3,0,0,0], m = 3  
nums2 = [2,5,6], n = 3  

출력:  
[1,2,2,3,5,6]  

설명:  
병합할 배열은 [1,2,3]과 [2,5,6]이며,  
병합 결과는 [1,2,2,3,5,6]이다.  

---

**예제 2**

입력:  
nums1 = [1], m = 1  
nums2 = [], n = 0  

출력:  
[1]

---

**예제 3**

입력:  
nums1 = [0], m = 0  
nums2 = [1], n = 1  

출력:  
[1]  

설명:  
m = 0이므로 nums1에는 실제 원소가 없고,  
0은 단지 결과를 담기 위한 공간일 뿐이다.

---

## 📋 제약 조건 (Constraints)

- nums1.length == m + n  
- nums2.length == n  
- 0 <= m, n <= 200  
- 1 <= m + n <= 200  
- -10⁹ <= nums1[i], nums2[j] <= 10⁹  

---

## 💡 접근 방식

`nums1`의 뒷부분이 비어 있으므로, 뒤에서부터 채워나가는 방식으로 해결할 수 있다.

1. **세 개의 포인터 사용**
   - `p1`: nums1의 실제 마지막 원소 위치 (m - 1)
   - `p2`: nums2의 마지막 원소 위치 (n - 1)
   - `p`: nums1의 마지막 인덱스 (m + n - 1)

2. **뒤에서부터 비교하며 큰 값을 nums1[p]에 삽입**
   - nums1[p1]과 nums2[p2] 중 큰 값을 nums1[p]에 넣고, 해당 포인터를 한 칸 이동
   - p도 한 칸 감소

3. **nums2가 남은 경우 복사**
   - nums2에 남은 원소가 있으면 nums1의 앞부분에 그대로 복사

이 방식은 불필요한 배열 복사를 방지하며,  
시간복잡도는 **O(m + n)**, 공간복잡도는 **O(1)** 이다.
