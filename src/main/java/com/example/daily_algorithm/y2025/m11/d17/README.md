# 🧩 15. 3Sum (해결 실패)

**난이도:** Medium  
**플랫폼:** LeetCode  
**유형:** Two Pointers / Sorting  
**링크:** https://leetcode.com/problems/3sum/
---

## 📝 문제 설명

정수 배열 `nums`가 주어졌을 때,  
다음 조건을 만족하는 **서로 다른 세 수의 조합(triplet)** 을 모두 찾아라.

- 세 인덱스는 서로 달라야 한다.  
  (i ≠ j, i ≠ k, j ≠ k)
- `nums[i] + nums[j] + nums[k] == 0`

또한 **중복된 조합은 포함되지 않아야** 한다.  
(같은 숫자 조합이 여러 번 등장하면 한 번만 포함)

출력되는 삼중 조합의 순서나 조합 내부 원소의 순서는 중요하지 않다.

---

## 🔍 예시

**예시 1**  
입력:  
`nums = [-1,0,1,2,-1,-4]`  
출력:  
`[[-1,-1,2], [-1,0,1]]`

설명:
- (-1) + 0 + 1 = 0
- 0 + 1 + (-1) = 0
- (-1) + 2 + (-1) = 0  
  중복을 제거하면 위 두 조합만 남는다.

---

**예시 2**  
입력:  
`nums = [0,1,1]`  
출력:  
`[]`  
설명:  
가능한 어떤 조합도 0이 되지 않으므로 빈 배열을 반환.

---

**예시 3**  
입력:  
`nums = [0,0,0]`  
출력:  
`[[0,0,0]]`  
설명:  
0 + 0 + 0 = 0 이므로 유일한 조합 하나만 존재.

---

## 📋 제약 조건 (Constraints)

- 3 <= nums.length <= 3000
- -10⁵ <= nums[i] <= 10⁵
---
## 💡 접근 방식

1. 정렬하기

먼저 배열을 정렬한다.
- 정렬 후에는 같은 값이 연속으로 모이기 때문에
→ 중복인 값들을 쉽게 건너뛸 수 있고
- 투 포인터로 합을 키우거나 줄이는 방향을 직관적으로 결정할 수 있다.

2. i를 고정하고, 나머지 두 수는 투 포인터로 찾기

- 첫 번째 원소의 인덱스를 i라고 두고,
- 나머지 두 수는 정렬된 구간에서 투 포인터로 탐색한다.
  - left = i + 1
  - right = nums.length - 1

반복하면서:
- sum = nums[i] + nums[left] + nums[right]
- sum == 0 → 정답 조합 → 리스트에 추가
- sum < 0 → 합을 키워야 하므로 left++
- sum > 0 → 합을 줄여야 하므로 right--

3. 중복 제거 처리

정렬 상태를 이용해 중복 조합을 제거한다.
- 바깥 반복에서:
 -i > 0 이고 nums[i] == nums[i-1] 이면
→ 이미 처리한 값이므로 continue 로 넘어간다.

- 안쪽에서 sum == 0 인 조합을 찾은 뒤:
  - left 를 증가시키면서 이전 left와 같은 값들은 모두 건너뛰기
  - right 를 감소시키면서 이전 right와 같은 값들은 모두 건너뛰기

이렇게 하면 [ -1, -1, 2 ] 같은 조합이 여러 번 나오는 것을 방지할 수 있다.